/* eslint-disable no-template-curly-in-string */
export const data = {
    Python: {
        List: [
            {'x = [1, 3, 4]': 'Список, содержащий элементы одного типа данных'},
            {'y = [1, 3.2, \'str\']': 'Список, содержащий элементы различных типов данных'},
            {'len(x)': 'Вернет длину списка'},
            {'x[0]': 'Вернет первый элемент списка'},
            {'x[-1]': 'Вернет последний элемент списка'},
            {'x[1:]': 'Вернет срез строк начиная со второго'},
            {'[1, 3] + [3, 4]': 'Вернет сконкатенированный список'},
            {'x[0] = 5': 'Меняет элемент списка по его индексу'},
            {'x.append(123)': 'Добавляет элемент в конец списка'},
            {'x.pop()': 'Удаляет из списка элемент и Вернет его'},
            {'x.pop(0)': 'Удаление по индексу'},
            {'x.sort()': 'Сортирует по возрастанию, так же для строк'},
            {'x.reverse()': 'Переворачивает список'},
            {'x.insert(1, 22)': 'Вставить элемент 22 по индексу 1 и сдвинуть остальные вперед'},
            {'x.index(22)': 'Вернет индекс элемента(ошибка если элемента нет)'},
            {'[1, 1, 2, 3].count(1)': 'Вернет число повторов элемента'},
            {'a = b.copy()': 'а копирует b'},
            {'a.clear()': 'Удаляет все элементы из списка'},
        ],
        Dict: [
            {'x = { "r": 7, "e": 8 }': 'Пример словаря, ключ + значение'},
            {'x = dict(r=7, e=8)': 'Пример словаря, ключ + значение (другая запись)'},
            {'x[key]': 'Вернет 7 - обращение по ключу'},
            {'x.get(key)': 'Вернет 7 - обращение по ключу (другая запись)'},
            {'x[key] = "+1"': 'Добавляет пару в конец словаря'},
            {'x[key] = "+12"': 'Смена текущего значения'},
            {'list(x.keys())': 'Вернет список из ключей словаря'},
            {'list(x.values())': 'Вернет список из значений словаря'},
            {'sorted(x.keys())': 'Вернет уже отсортированный список'},
            {'key in x': 'Вернет bool значение, есть ли в словаре элемент'},
            {'key not in x': 'Вернет bool значение, нет ли в словаре элемента'},
            {'for k, v in x.items():': 'Перебор ключей и значений'},
            {'del x[key]': 'Удалить элемент'},
            {'x.pop(key)': 'Удалить элемент'},
            {'x.popItem()': 'Вернет последний элемент и его же удалит из словаря'},
            {'len(x)': 'Вернет длину словаря'},
        ],
        OrdDict: [
            {'from collections import OrderedDict': 'Импорт библиотеки'},
            {'b = OrderedDict()': 'Инициализация переменной'},
        ],
        Tuple: [
            {'a = ("1", "2", "3")': 'Объявление tuple'},
            {'a[0] = 4':'Ошибка, элементы кортежа неизменяемы'},
            {'len(a)':'Вернет длину tuple'},
        ],
        NamedTuple: [
            {'from collections import namedtuple': 'Импорт namedtuple'},
            {'Human = namedtuple("Human", "name age eyecolor")':'Определение класса human'},
            {'albert = Human("Albert", "27", "Brown")':'Создание экземпляра класса'},
            {'albert.name': 'Вернет значение свойства name'},
        ],
        Logic: [
            {'if True:': 'Если'},
            {'result = input()': 'Запрос от пользователя'},
            {'elif True:': 'В другом случае, если'},
            {'else:': 'Во всех остальных случаях'},
        ],
        Set: [
            {'x = set()': 'Создать set'},
            {'x.add(1)': 'Добавить элемент'},
            {'set([1,1,2,3])': 'Вернет set из list без дубликатов'},
            {'1 in x': 'Вернет bool, проверка на наличие числа в set'},
            {'{1,2}.issubset({1,2,3})': 'Вернет bool, является ли первый подмножеством второго'},
            {'{1,2,3}.issuperset({1,2})': 'Вернет bool, является ли первый надмножество второго'},
            {'x.isdisjoint(y)': 'Вернет bool, нет ли совпадений, если нет то true'},
            {'a = x.union(y)': 'Вернет новое объединенное множество без дубликатов'},
            {'a = x.intersection(y)': 'Вернет новое множество из совпадающих значений'},
            {'a = x.difference(y)': 'Вернет новое множество, из уникальных значений из левого множества'},
            {'a = x.symmetric_difference(y)': 'Вернет новое множество из уникальных значений левого и правого множеств'},
            {'a = x.update(y)': 'Работает как union, только не возвращает новое, а обновляет левое множество'},
            {'x.remove(1)': 'Удалить элемент, ошибка если элемента нет'},
            {'x.discard(1)': 'Удалить элемент, ошибки нет если элемента нет'},
            {'x.pop()': 'Удаляет случайный элемент и вернет его'},
            {'x.clear()': 'Очистка множества'},
        ],
        For: [
            {'for i in [1,2,3,4]:': 'Каждую итерацию на место i будет подставляться значение из list'},
            {'for i in range(2,5):': '2,3,4 В i будут числа из range от 2 до 5 не включая 5'},
            {'for i, item in enumerate(nums):nums[i] *= 2': 'Умножить все значения в num на 2'},
            {'for l in "Albert":': 'В l будет буква из имени каждую итерацию'},
            {'for _ in range(5):': 'Не используем переменную _, просто 5 итераций'},
            {'for i in ("John", 22):': 'В i будут элементы из tuple'},
            {'for (x, y) in [(5, 4), (7, 9)]:': 'В x и y будут значения из tuple'},
            {'for items in dict(a=5, b=2):': 'Выведет ключи, тоесть буквы a и b'},
            {'for items in dict(a=5, b=2).items():': 'Выведет 2 tuple'},
            {'for k, v in dict(a=5, b=2).items():': 'k будет ключи, v - значение'},
            {'for v in dict(a=5, b=2).values()': 'Итерирование значений 5, 2'},
            {'for i in list1: for y in list2:': 'Вложенный цикл'},
        ],
        ListComprehension: [
            {'a = [l for l in "str"]': 'Вернет ["s", "t", "r"]'},
            {'a = [l for l in range(5) if l < 3]': 'Вернет [0, 1, 2], исходя из условия'},
            {'d = ["M" if num > 20 else "L" for num in [12, 30]]': 'Вернет ["L", M"]'},
        ],
        While: [
            {'while x < 3: x++': 'Закончит когда x станет 3'},
            {'else:': 'Выполняется 1 раз, сразу после выхода из while'},
            {'break': 'Выход из цикла'},
            {'continue': 'Перейти к следующей итерации немедленно'},
            {'pass': 'Заглушка для пустого цикла'},
        ],
        InternalFunctions: [
            {'abs(-1) abs(1)': 'Вернет такое же положительное число'},
            {'max(1,2,3) min([1,2,3])': 'Вернет максимальное и минимальное число'},
            {'pow(2, 8)': 'Вернет 2 в 8-ой степени'},
            {'round(1.23, 1) round(1.2)': 'Вернет округленное 1.2 и 1'},
            {'sum([1,2,3])': 'Вернет сумму элементов списка, не принимает просто числа без списка'},
            {'hex(42) oct(42) bin(42)': 'Вернет число в шетндарцатитрчной / восьмеричной / двоичной системе'},
            {'all([...])': 'Принимает список из boolean, вернет True если все из них True, иначе False'},
            {'any([...])': 'Принимает список из boolean, вернет True если хоть один из них True, иначе False'},
            {'a = zip("abs", (1,2,3)) list(a) dict(a)': 'Вернет список из склеинных tuple или dict, оптимизированное склеивание'},
            {'ord("a") chr(97)': 'Вернет его позицию в unicode и наоборот'},
        ],
        Functions: [
            {'def foo(): ...': 'Определение функции'},
            {'foo()': 'Вызов функции'},
            {'def foo(arg1, arg2): ..': 'Принять аргументы из вызова'},
            {'foo("arg", "onemorearg")': 'Передать аргументы при вызове'},
            {'def foo(arg="some")': 'Аргумент по умолчанию'},
            {'result = foo()': 'В result запишется то, что вернула функция'},
            {'def foo(): return 123': 'Вернуть чтото при вызове функции'},
            {'def foo(*args): for i in args: ..': 'В agrs лежат все аргументы переданные в функцию'},
            {'def foo(**kwargs): for k, v in args: ..': 'Принимать все аргументы как пары ключ значение'},
        ],
        LambdaMapFilter: [
            {'map(lambda name: name[0], ["Ivan", "Albert"])': 'Map принимает функцию и список, вернет первые буквы'},
            {'filter(lambda age: age > 17, [15,20,29])': 'Filter принимает функцию и список, вернет отфильтрованный список'},
        ],
        Scope: [
            {'a = 5 def foo(): a = 6 print(a)': 'a отсанется 5 так как язык берет значение из текущего окружения'},
            {'def foo():global a a = 6': 'работать с переменной глобального окружения'},
        ],
        Decorators: [
            {'from functools import wraps': ''},
            {'def decorator_name():': ''},
            {'--@wraps(func)': 'Способ сохранить имя функции при декорировании'},
            {'--def wrap(*args, **kwargs):': ''},
            {'----print("start")': ''},
            {'----func(*args, **kwargs)': ''},
            {'----print("finish")': ''},
            {'--return wrap': 'Cпособ создать декоратор'},
            {'@decorator_name': ''},
            {'def foo(): print(123)': 'Способ добавить декоратор к функции'},
        ],
        Try: [
            {'try: 4 / 0': 'Попытка выполнить код'},
            {'except Exception as ex: print(ex)': 'Если в try ошибка, выполнится этот блок (отловить ошибку и ее тип)'},
            {'finally:': 'Выполняется всегда, после выполнения блоков try / except'},
            {'raise TypeError("description")': 'Вызвать ошибку какого либо типа с ее описанием'},
            {'class SomeError(Exception): """description"""': 'Создать конструктор класса ошибки'},
        ],
        CreatingClass: [
            {'class TreeFruit:': 'Каждое слово в названии класса с большой буквы'},
            {'--def __init__(self, name, color=yellow):': 'Конструктор класса, принимает в аргументы сам класс и свойства'},
            {'----self.name = name': 'Создание атрибута (переменной) внутри класса'},
            {'----self.age = 0': 'Создание атрибута (переменной) внутри класса'},
            {'--def fall(age): ...': 'Метод того что фрукт упадет при определенном возрасте'},
            {'banana = TreeFruit("Banana")': 'Создать экземпляр класса'},
            {'mango = TreeFruit("Mango")': 'Создать еще один независимый экземпляр'},
        ],
        PrivateAttr: [
            {'PI = 3.14': 'Атрибуты констант капслоком'},
            {'_protected': 'Защищенный атрибут (запись и чтение из класса и наследников)'},
            {'__private': 'Приватный атрибут (запись и чтение из класса)'},
            {'@property def private(self): return self.__private': 'Доступ к чтению свойства'},
            {'@private.setter def private(self, value): pass': 'Сеттер для свойства'},
        ],
        StaticMethods: [
        ],
        Inherintance: [
            {'class a:': ''},
            {'class b(a):': 'Класс b наследуется от a.'},
            {'': 'Класс b будет иметь доступ к атрибутам и методам класса a'},
            {'': 'Класс b может иметь собственную реализацию для этих атрибутов и методов'},
            {'': 'Если в классе b нет какой то сущности, она ищется в классе a'},
            {'for cls in [classA, classB, classC]: print(cls.prop)': 'Проявление полиморфизма - это получение доступа к одноименным сущностям'}
        ]
    },
    Js: {
        Variables: [
            {'let a;': 'Объявление переменной'},
            {'a = 5': 'Присвоение значения'},
            {'const b = 7;': 'Неизменяемая переменная'},
            {'b = 15': 'Ошибка, константы неизменяемы'},
            {'let camelCase;': 'Каждое новое слово с большой буквы'},
            {'let ourPlanetName = "Earth"': 'Имя переменной должно описывать что внутри'}
        ],
        TypeNumber: [
            {'let n = 123;': 'Число'},
            {'n = 1.23': 'С плавающей точкой'},
            {'n = 1 / 0': 'Infinity. Бесконечность'},
            {'n = \'str\' - 5': 'NaN. Вычислительная ошибка'},
        ],
        TypeString: [
            {'let s = \'some string\'': 'Строка'},
            {'s = "some string 2"': 'Эти кавычки тоже подходят'},
            {'s = `some ${typeof s} 3`': 'Кавычки для использования js в строке'},
        ],
        TypeBoolean: [
            {'a = true': 'Имеет всего два значения'},
            {'b = false': 'true и false (правда, неправда)'},
        ],
        Other: [
            {'let a = Null': 'Null. Ничего, пусто'},
            {'let b;': 'undefined. b не определена, только объявлена'},
            {'let c = 12345601234567890n;': 'bigInt. Для больших чисел'},
            {'typeof x': 'Вернет тип переменной в виде строки'},
        ],
        Interaction: [
            {'alert("Hello");': 'Вывод окна с информацией'},
            {'result = prompt(title, default);': 'Получение информации от пользователя, вернет строку или null'},
            {'result = confirm(question);': 'Вернет boolean'},
            {'': 'Каждая из функций останавливает выполнение скрипта.'},
        ],
        TypeConversions: [
            {'String(1)': '"1"'},
            {'String(true)': '"true"'},
            {'String(null)': '"null"'},
            {'String(undefined)': '"undefined"'},
            {'Number("1")': '1'},
            {'Number(""': '0'},
            {'Number("text")': 'NaN'},
            {'Number(true)': '1'},
            {'Number(false)': '0'},
            {'Number(undefined)': 'NaN'},
            {'Number(null)': '0'},
            {'Boolean(0)': 'false'},
            {'Boolean(1)': 'true'},
            {'Boolean("")': 'false'},
            {'Boolean("0")': 'true'},
            {'Boolean(" ")': 'true'},
            {'Boolean(null)': 'false'},
            {'Boolean(undefined)': 'false'},
            {'Boolean(NaN)': 'false'},
        ],
        Comparisons: [
            {'5 > 4, 4 == 4, 7 != 3': 'Вернут boolean'},
            {'"a" > "Я"': 'true, так как маленькая "a" в unicode больше'},
            {'true > null': 'При сравнении разных типов, приводит оба к числу'},
            {'5 === "5"': 'false, сравнение по значению и типу данных'},
            {'': 'Желательно сравнивать сущности одного типа данных'},
        ],
        If: [
            {'if(a == 1) {..code}': 'Приводит выражение из скобок к boolean и если true выполняет code'},
            {'else if (a == 2) {..code}': 'Если в первом if false, проверяет свои скобки, и если true выполняет code'},
            {'else {..code}': 'Если предыдущие проверки вернули false, выполниться блок и else'},
            {'let a = условие ? значение1 : значение2': 'Условие вернет boolean, если оно true, то а = значение1, иначе a = значение2'},
        ]
    },
    JsAdv: {
        Recursion: [
            {'function foo(x, times) {': 'Foo calls recursion, times is recursion depth'},
            {'return x === 1 : x ? x * foo(times - 1, x)}': 'Calling foo, while x != 1'},
        ],
        ExecutionContext: [
            {'When a function makes a nested call, happens:': 'The current function is paused.'},
            {'': 'The execution context is remembered in a execution context stack.'},
            {'': 'The nested call executes (new context).'},
            {'': 'Outer function is resumed from where it stopped.'},
        ],
        RestParameters: [
            {'function sum(...rest) {': 'Rest is an array of all of parameters'},
            {'return rest.reduce((p,c) => (p + c), 0);}': 'Reducing array to get common sum'},
            {'sum(1, 23, 54, 13);': 'Calling, it cans contain different count of numbers'},
            {'function some(first, second, ...rest) {}': 'First and second parameters as vars'},
        ],
        Spread: [
            {'let arr = [1, 2, 3]; Math.max(...arr);': 'Spread arr to mathmax foo'},
            {'Math.max(...arr1, 23, ...arr2, 2, 15)': 'Any count of arrays and values'},
            {'let merge = [...arr1, ...arr2, 141]': 'Merge in a new var'},
            {'let a = [..."Hello"]': 'Split string to letters'},
            {'let copy = {...obj}': 'Copy arr or obj'},
        ],
        LexicalEnvironment: [
            {'let some = 5;': 'some is a part of Environment Record (global)'},
            {'': 'Global Environment Record hasnt outer Lexical environment'},
            {'some = 6': 'Environment Record is changed, it has a new value'},
        ],
        FunctionDeclaration: [
            {'': 'function hello is already a part of global Environment Record'},
            {'let name = "Ivan"': 'name variable became a part of global Environment Record'},
            {'function hello() { alert(`hello ${name}`) }': ''},
        ],
        InternalExternalLexicalEnvironment: [
            {'': 'function hello is already a part of global Environment Record'},
            {'let phrase = "Ivan"': '"name" variable became a part of global Environment Record'},
            {'function hello() { alert(`${phrase} ${name}`) }': 'hello has own environment'},
            {'hello("Ivan")': '"Ivan" is a part of Environment Record of hello'},
            {'': '"phrase" is a part of global environment and outer environment of function'},
            {'': 'when foo is running it looking for "phrase" in internal env then in outer'},
            {'': 'when foo is running it use own current env each calling'},
        ],
        FooFromFoo: [
            {'function makeCounter() {': '"makeCounter" has own env (ENV global)'},
            {'let count = 0': '"count" became a part of "makeCounter" env'},
            {'return function() { return ++count; } }': 'it has own env and "makeCounter" as constant(ENV obj) outer'},
            {'let counter = makeCounter();': '"counter" will have "makeCounter" as a constant outer env'},
            {'counter()': '1// increase count'},
            {'counter()': '2// increase count one more'},
            {'': 'it happend because each calling of counter have same "makeCounter" env'},
            {'': 'Замыкание - функция, что видит свои внешние переменные и имеет к ним доступ'},
        ],
        Var: [
            {'': '"a" already exist in global environment'},
            {'var a = 5': '"a" have already existed in begin of function or script'},
            {'var a = 7': 'its not a problem, we can redeclarate it a lot of times'},
            {'': 'we can see "a" even if it is in enclose scope (like if or for)'},
        ],
        GlobalObject: [
            {'globalThis': 'Its the common way to get access to the global object(browser, node etc)'},
            {'var a = 5; window.a': 'After creating, var became a part of globalThis'},
            {'window.Promise': 'Checking browser to support'},
        ],
        FunctionObject: [
            {'function foo() {}; foo.name': '"foo" is name of the function'},
            {'foo.length': 'Arguments count'},
            {'foo.counter = 0': 'Creating addictional props for foo'},
        ],
        newFunction: [
            {'let sum = new Function("a", "b", "return a + b");': 'Creating new foo by strings during of execution'},
            {'sum(1,2)': 'Returns 3'},
        ],
        setTimeoutSetInterval: [
            {'let a = setTimeout(nameOfFoo, delay, arg1, arg2 ..)': 'Creating timeout'},
            {'clearTimeout(a)': 'Removing timeout before execution'},
            {'let a = setInterval(nameOfFoo, delay, arg1, arg2 ..)': 'Creating interval'},
            {'clearInterval(a)': 'Removing interval before or during execution(no matter)'},
            {'setTimeout(() => alert("Мир"));': 'It will be working after end of execution of script'},
        ],
        FunctionCacheDecorator: [
            {'function slow(x) { return x ** 2; }': 'Slow function'},
            {'function funcCache(func) {': 'Function Decorator'},
            {'let cache = new Map();': 'Cache is inside funcCache env'},
            {'return function (x) {': 'Cache is in outer env'},
            {'if (cache.has(x)) return cache.get(x);': 'Check map'},
            {'let result = func(x); cache.set(x, result); return result': 'Save and return result'},
            {'}} slow = funcCache(slow);': 'Add cache possibility to slow func'},
        ],
        CallApplyBind: [
            {'foo.call(this, ...args)': 'Pass context to called function, args can be object'},
            {'foo.apply(this, args)': 'Pass context to called function, args must be array'},
            {'let key = "arg1 + "," + arg2"': 'If we have more then 1 arg to cache, we can hash it'},
            {'[].join.call(arguments)': 'Way to hash pseudo-array'},
            {'': 'Passing all arguments along with the context is called call forwarding.'},
            {'Decorators': 'transparentCache, spyOn, debounce, delay'},
            {'some = func.bind(context)': 'some have a func with right context'},
        ],
        ArrowFuncSpecials: [
            {'(() => ())': 'Don\'t have this'},
            {'': 'Can\'t be called with new'},
            {'': 'Don\'t have arguments obj'},
            {'': 'Don\'t have super'},
        ],
        Descriptors: [
            {'Object.getOwnPropertyDescriptor(user, "name");': 'get “property descriptor” obj'},
            {'Object.defineProperty(user, "name", {..: ..})': 'set “property descriptor”'},
            {'{writable: false}': 'property is read-only'},
            {'{enumerable: false}': 'property is not iterable'},
            {'{configurable: false}': 'prop descriptors is not changable(only write on=>off), and prop is not delitable'},
            {'Object.defineProperties(user, {': ''},
            {'--name: {value: "Myafa", configurable: false}': ''},
            {'--age: {value: 3, writable: true}})': 'define many props'},
            {'Object.getOwnPropertyDescriptors(user)': 'get “property descriptors” obj'},
            {'let clone = Object.defineProperties({': ''},
            {'}, Object.getOwnPropertyDescriptors(user));': 'clone obj with descriptor”'},
        ],
        SealingObjectGlobally: [
            {'Object.preventExtensions(obj)': 'Forbids the addition of new properties to the object.'},
            {'Object.seal(obj)': 'Forbids add/remove props, make all of props non-configurable'},
            {'Object.freeze(obj)': 'Forbids add/remove/change props, make all of props non-configurable & non-writable'},
            {'Object.isExtensible(obj), Object.isSealed(obj), Object.isFrozen(obj)': 'check, return bool'},
        ],
        AccessorProperties: [
            {'let user = {': ''},
            {'--name: "Myafa",': ''},
            {'--surname: "Puflyandskaya",': ''},
            {'--get fullName() { return this.name + this.surname }': 'Accessor that get name'},
            {'--set fullName(value) {': ''},
            {'----[this.name, this.surname] = value.split(" ")]; },}; ': 'Accessor that set name'},
            {'': 'Object got new two descriptors get and set instead writible and value'},
            {'set name(value) { if (value.length) this._name = value }': ' properties starting with "_" should not be touched from outside'}
        ],
        PrototypalInheritance: [
            {'child.__proto__ = parent': 'It is the antient getter/setter of [[Prototype]] property'},
            {'childOfChild.__proto__ = child': 'childOfChild has all of methods and props of child and parent'},
            {'let user = {': ''},
            {'--get name() { return this._name }': ''},
            {'--set name(value) { this._name = value }': 'we can use getter/setter as inherited method'},
            {'parent = { name: "some" }': ''},
            {'child = { __proto__: parent }': ''},
            {'child.name = "smthng"': 'parent name is not changed, we can not write/delete inherited props, only read'},
        ],
        PrototypalInheritanceThis: [
            {'animal = { phrase: "Hello", say() { return this.phrase } }': ''},
            {'rabbit = { __proto__: animal }': ''},
            {'rabbit.say()': 'undefined // "this" is always the rabbit'},
            {'animal.say()': 'Hello // "this" is always the animal'},
        ]
    },  
    Jest: {
        Expect: [
            {'.toEqual(expect.anything());': 'Не null, не undefined'},
            {'.toEqual(expect.any(Number));': 'Проверка на экземпляр класса'},
            {'.toEqual(expect.arrayContaining([1, 2]));': 'Первый массив содержит второй'},
            {'.toEqual(expect.objectContaining({foo: 111}));': 'Первый объект содержит свойство'},
            {'.toEqual(expect.stringContaining("llo"));': 'Первая строка содержит подстроку'},
            {'.toEqual(expect.stringMatching("hello"));': 'Совпадение строк или с регуляркой'},
            {'.toBeCloseTo(0.3);': 'Убирает проблему сложения десятичных дробей'},
            {'.not': 'opposite of expression'},
            {'.resolve': 'resolve promise before matching'},
            {'.rejects': 'reject promise before matching'},
            {'.toBeCalled()': 'foo was called no less then 1 time'},
            {'.toBeCalledTimes(2)': 'foo was called 2 times'},
            {'.toBeCalledWith(arg1, arg2)': 'foo was called with these args any time'},
            {'.lastCalledWith(arg1, arg2)': 'foo was called with these args last time'},
            {'.nthCalledWith(2, arg)': 'one of times the arg was second'},
            {'.toReturn()': 'foo returned something some time'},
            {'.toReturnWith(111)': 'foo returns 111'},
            {'.lastReturnWith(111)': 'foo returned 111 last time'},
            {'.nthReturnWith(111)': 'foo returned 111 one of times'},
            {'.toHaveLength()': 'to have equal string s of array s length'},
            {'.toHaveProperty(key, value?)': 'is there a key and an optional value'},
            {'.toBeInstanceOf(class)': 'is value to be equal with the class prototype'},
            {'.toContain(1)': 'value into array'},
            {'.toMatch(str)': 'regexp'},
            {'.toThrow()': 'throw mistake'},
            {'.toBe(), .toBeNull(), .toBeUndefined(), .toBeDefined(), .toBeTruthy(), .toBeFalsy(), .toBeNaN()': ''},
        ]
    },
    React: {
        JSX: [
            {'const btn = <button>push</button>': 'Поместить dom элемент в переменную'},
            {'(<div><button>123</button></div>)': 'Многострочный элемент в скобках'},
            {'(<><button>123</button><button>123</button></>)': 'Несколько элементов должны быть обернуты в один'},
            {'<div>{var}</div>': 'Использование переменных внутри тега'},
            {'<p>123</p>; <div>{p}</div>': 'Использование переменных внутри тега'},
            {'<input placeholder={holder} />': 'Использование переменных внутри атрибута'},
            {'<div className="some"></div>': 'Имена классов в className, многострочные атрибуты camelCase'}
        ],
        Props: [
            {'<Some name="Albert" surname="Petr" />': 'Pass info to a child'},
            {'<Some onDelete={() => something} />': 'Pass foo to a child'},
            {'export interface Props { name: string, surname: string }': 'Interface of input props'},
            {'export default class Some extends Component<Props, {}>': 'Class with an interface'},
            {'const { name, surname } = this.props': 'Get props'},
        ],
        State: [
            {'state = { key: value }': 'Set state'},
            {'const { key } = this.state': 'Get state'},
            {'this.setState((state: any) => ({ key: ++state.key }))': 'Change state value (only arrow functions or bind this)'},
            {'': 'We should return new values in state, not changed old'},
        ],
        CSSModules: [
            {'create App.module.css': 'creating module style file'},
            {'import style from "./App.module.css";': 'Import requires declaration.d.ts if ts'},
            {'<div className={style.className}></div>': 'Adding class to an element'},
        ],
    },
    ReactNew: {
        HelloWorld: [
            {'<div id="root"></div>': 'The root tag in index.html'},
            {'const root = ReactDOM.createRoot(document.getElementById("root"));': 'Creating root index.tsx'},
            {'root.render(<h1>Привет, мир!</h1>);': 'Render something index.tsx'},
            {'': 'React compares new and old ReactDOM to render only changed elems'},
        ],
        JSX: [
            {'const element = <h1>Привет, мир!</h1>;': 'Example of declaring JSX element'},
            {'const element = <h1>Здравствуй, {name}!</h1>;': 'Inserting any JS code'},
            {'function foo() { return <a>123</a> }': 'JSX is also JS expression, we can use it inside if for etc'},
            {'const element = <img src={user.avatarUrl}></img>;': 'Using attributes'},
            {'const element = (<div><div></div></div>)': 'Circle brackets for multiline expression'},
            {'const element = React.createElement("h1","text")': 'React.createElement does same as simple appropriation'},
        ],
        CompsNProps: [
            {'function foo(props) { return <div>{props.name}</div> }': 'React component as a function'},
            {'class Cls extends React.Component {': ''},
            {'constructor(props) { super(props) }': 'If we are adding constructor, we must write this'},
            {'render() { return <div>{props.name}</div> }}': 'React component as a class'},
            {'const element = <Myclass name="Алиса" />;': 'Send data to a child'},
            {'': 'We shouldnt change props in execution time (components are pure)'},
        ],
        StateNLifeCycle: [
            {'this.state = { ... }': 'Starting set state'},
            {'componentDidMount() {}': 'Works after first mounting (after rendering)'},
            {'componentWillUnmount() {}': 'Works before destruct of DOM node'},
            {'this.setState((state, props) =>': ''},
            {'({ some: state.a + props.b }))': 'How to set state properly, it invokes rendering'},
        ],
        HandlingEvents: [
            {'onClick={foo}': 'Handler camelCase, pass foo without brackets'},
            {'function handleSubmit(e) { e.preventDefault(); }': 'Prevent only inside foo'},
            {'this.handleClick = this.handleClick.bind(this);': 'This binding is necessary to make `this` work in the callback'},
            {'onClick={() => foo()}': 'The way to not binding foo '},
            {'<button onClick={(e) => this.foo(id, e)}></button>': ''},
            {'<button onClick={this.foo.bind(this, id)}></button>': 'Ways to passing data to foo'},
            {'': ''},
        ]
    },
    Redux: {
        Actions: [
            {'Actions': 'Action is an event that describes something that happened'},
            {'const doSomeAction = { type: "where/whatToDo" }': 'An obj that has "type" prop that describe where/whatToDo'},
            {'payload: "some"': 'Addictional prop of actions, it can has addictional info'},
            {'const addTo = txt => { return { type: "..", payload: txt } }': 'Action creator, we use to not creating actions by hand'},
        ],
        Reducers: [
            {'Reducer': 'It is a listener that desides how to change state looking on action'},
            {'': 'They should only calculate the new state value'},
            {'': 'They are not allowed to modify the existing state, only creating new'},
            {'function nameOfRdcr(state, action) { return state }': 'Reducer without changing state'},
            {'(state = { value: 0 }, action)': 'initial state'},
            {'if (action.type = ".."){return: { ...state, a: ++state.a }}': 'If action is .. copy and return new state'},
        ],
        Store: [
            {'Store': 'The current Redux application state lives in an object called the store'},
            {'import { configureStore } from "@reduxjs/toolkit"': 'For using configureStore'},
            {'const store = configureStore({reducer: nameOfRdcr})': 'Creating store by using reducer'},
            {'store.getState()': 'Get current state from store'},
        ],
        Dispatch: [
            {'store.dispatch({ type: "counter/increment" })': 'One way to update state by passing action object'},
            {'const incr = () => { return { type: "/" } }': 'Function that returns action'},
            {'store.dispatch(incr())': 'Call by using action foo'},
        ],
        Selectors: [
            {'Selectors': 'Helps us to getting needable value from state'},
            {'const selectValue = state => state.value': 'Returns value from state'},
            {'const currentValue = selectCounterValue(store.getState())': 'Get needable value'},
        ],
    },
    Angular: {
        Installing: [
            {'ng new <project-name>': 'Installing a ng project by using cli'},
        ],
        ComponentCreate: [
            {'ng g c <component-name>': 'Creating component with its path in app/'}
        ],
        CreatingManually: [
            {'import { Component } from "@angular/core";': 'Import to use decorator'},
            {'@Component({})': 'Place for metadata of a component'},
            {'selector: "app-component"': 'Selector of a component, using to add comp each detection'},
            {'templateUrl: "./component-overview.component.html"': 'Include external tempate'},
            {'styleUrls: ["./component-overview.component.css"]': 'Include external styles'},
            {'export class AppComponent {}': 'Export class'},
        ],
        LifeCycleHooks: [
            {'export class AppComponent implements OnInit': 'Implement OnInit'},
            {'ngOnInit()': 'Perform heavy logic outside of the constructor'},
            {'': 'The best place to work with start-input data'},
            {'': 'Working once after OnChanges()'},
            {'ngOnDestroy()': 'The place to free resources that wont be garbage-collected automatically'},
            {'': 'Unsubscribe, remove timers'},
            {'': 'Working once before destruct a component'},
            {'ngOnChanges()': 'Working whenever changes in the input properties was detected'},
            {'ngOnChanges(changes: SimpleChanges)': '"Changes" stores data about prev and current values'},
            {'': 'Isnt working when input data is an object && we change object\'s properties'},
            {'': 'Isnt working without input data'},
            {'ngAfterViewInit()': 'Working once after rendering children'},
            {'ngAfterViewChecked()': 'Working each children checking'},
            {'': 'We can get access to children only after first AfterViewInit'},
            {'ngAfterContentInit()': 'Working once after projecting elements to children'},
            {'ngAfterContentChecked()': 'Working each content checking'},
            {'ngDoCheck()': 'Monitor changes that occur where ngOnChanges() won\'t catch them'},
            {'': 'Working each change detection'},
        ],
        ViewIncapsulated: [
            {'ViewEncapsulation.Emulated': 'CSS style influences only on own component'},
            {'ViewEncapsulation.None': 'CSS style influences anywhere'},
            {'_nghost, _ngcontent': 'Angular adds these attributes to create incapsulating'},
        ],
        PassDataToChildByInput: [
            {'<app-child [data]="data"></app-child>': 'Pass data to child'},
            {'@Input() data: \'type\' = basicValue;': 'Get data from parent'},
            {'ngOnChanges(change: SimpleChanges) {}': 'It works each input data changes'},
        ],
        PassDataToParentByOutput: [
            {'<app-child (emitter)="foo($event)></app-child>': 'Get data from child'},
            {'@Output() emitter = new EventEmitter<type>();': 'Create emitter in child'},
            {'this.emitter.emit(data);': 'Pass data to parent foo'},
        ],
        LocalVariable: [
            {'<child #child></child><div>{{child.data}}<div>': 'Get value from child'},
            {'<child #child></child><p (click)="child.foo()"></p>': 'Invoke childs method'},
        ],
        ViewChild: [
            {'@ViewChild(ChildComponent)': 'Get it'},
            {'private childComponent: ChildComponent;': 'Put into var'},
            {'ngAfterViewInit() { child.method() }': 'Use childs methods and props'},
        ],
        Services: [
            {'ng g c "way/name"': 'Create service by cli'},
            {'export class NewService {}': 'Export service'},
            {'import { NewService } from ...': 'Import service'},
            {'constructor (private new: NewService) {}': 'Create an instance by DI'},
            {'new.method()': 'Profit'},
        ],
        CSSSelector: [
            {':host {}': 'Using for this component and its children'},
            {':host(.active) {}': 'Using for this component, if it has .active class'},
            {':host h2 {}': 'Using for children h2'},
            {':host-context(selector) {}': 'It works same :host, only if any parent has this selector'},
            {'::ng-deep h2 {}': 'This style works as a global style for all of app'},
            {':host ::ng-deep h2 {}': 'This style works as a global style for the comp and its children'},
            {'@import "../../some.css";': 'Import external css file into the current css file'},
        ],
        SingleSlotContentProjection: [
            {'<child>123</child>': 'Passing to the child'},
            {'<ng-content></ng-content>': 'Getting from the parent'},
        ],
        MultiSlotContentProjection: [
            {'<child><div some>123</div></child>': 'Passing to the child ng-content that have "some" selector'},
            {'<child><div>456</div></child>': 'Passing to the child ng-content without selector '},
            {'<ng-content select="[some]"></ng-content>': '123'},
            {'<ng-content></ng-content>': '456'},
        ],
        ConditionalContentProjection: [
            {'<child><ng-template d>..</ng-template></child>': 'd - is directive selector, pass info to child'},
            {'@Directive({selector: "[d]"})': 'Creating directive'},
            {'public info: TemplateRef<unknown>': 'Getting info from parent ng-template to the directive'},
            {'@ContentChild(DirectiveName) c: DirectiveName': 'Getting directive info'},
            {'<ng-container [ngTemplateOutlet]="c.info"></n..>': 'Accepting info from directive'},
            {'': 'ng-content always renders content, ng-container by condition'},
        ],
        DynamicComponents:[],
        AngularElements: [],
        Interpolation: [
            {'<p>{{ myVar }}</p>': 'Pass data from component to template as text'},
            {'<img src="{{ myLink }}">': 'Pass data from component to template as text attribute'},
        ],
        UnderstandingBinding: [
            {'Change Detection': 'Change Detection is responsible for keeping the view and the model in sync.'},
            {'Binding include': 'Text interpolation, property binding, event binding, two-way binding'},
            {'$event, *ngFor="let cus of cuss", #tempVar': 'Template vars is first'},
            {'directiveVar': 'Directive vars is second'},
            {'componentVar': 'Component vars is third'},
            {'Idemportant Expression': 'Idempotent expression always returns the same thing until one of its values changes.'},
        ],
        Bindings: [
            {'<div [attr.nameOfAttr]="expression"></div>': 'bind attr'},
            {'<div [class.className]="expression"></div>': 'bind single class'},
            {'<div [class]="classExpression"></div>': '"class1 class2"'},
            {'<div [class]="classExpression"></div>': '{class1: true, class2: false}'},
            {'<div [class]="classExpression"></div>': '["class1", "class2"]'},
            {'<div [style.styleName]="value"></div>': 'bind single class'},
            {'<div [style.width.px]="value"></div>': 'bind in units'},
            {'<div [style]="styleExpression"></div>': '"width: 100px; height: 100px;"'},
            {'<div [style]="styleExpression"></div>': '{width: "100px", height: "100px"}'},
            {'<button (click)="onSave()">Save</button>': 'bind event to foo'},
            {'<img alt="item" [src]="urltext">': 'bind url to src prop'},
        ],
        TwoWayBindings: [
            {'<child [(name)]="name"></child>': 'PARENT TwoWayBind'},
            {'@Input() name: string;': 'CHILD accept name'},
            {'@Output() nameChange = new EventEmitter<string>()': 'CHILD pass changing'},
            {'changeName.emit("newName")': 'CHILD change name'},
        ],
        Pipe: [
            {'{{value | pipe:format}}': 'Using pipes'},
            {'{{date | date:"dd-MM-yyyy"}}': 'Example'},
            {'{{amount | currency:"EUR"}}': 'Example'},
            {'{{text | uppercase}}': 'Example'},
            {'{{value | async}}': 'getting value from async primitive'},
            {'https://angular.io/api/common#pipes': 'pipes'},
        ],
        TemplateVar: [
            {'<input #some>': 'Get var into some'},
            {'<button (click)="pass(some.value)"><button>': 'Pass some value to component'},
            {'<form #itemForm="ngForm" (ngSubmit)="onSubmit(itemForm)">': 'Value of itemForm is not form element, it is instance of ngForm'},
        ],
        DirectivesTypes: [
            {'Component Directive': 'Using with templates'},
            {'Attribute Direcitve': 'Change appereance and behavior of an element, component, directive'},
            {'Structure Directive': 'Change DOM layout by adding and removing elems from DOM'},
        ],
        BuiltInAttributeDirectives: [
            {'[ngClass]="true: "class": "otherClass""': 'Choosing the right class'},
            {'[ngClass]="{class: true, otherClass: false}"': 'We can pass an object with classes'},
            {'[ngStyle]="{color: true ? "red" : "blue"}"': 'We can pass an object with styles'},
            {'[(ngModel)]="name"': 'We can change name two ways'},
            {'[ngModel]="name" (ngModelChange)="foo($event)"': 'Dividing prop and event'},
        ]
    },
}